# Hey Emacs, this is a -*- sh -*- file ...
# NOTE: This file is meant to be sourced (e.g. from .bashrc or .zshrc)

# Last modified: <20251212.1911>

# Exit if not running in Zsh.
if [ -z "$ZSH_VERSION" ]; then
    printf >&2 "ERROR: This script requires Zsh. Aborting.\n"
    return 1
fi

# Set the maximum directory stack size to 10.
DIRSTACKSIZE=10
export DIRSTACKSIZE

setopt AUTO_PUSHD
setopt PUSHD_IGNORE_DUPS

# Define aliases for switching to specific stack entries (cd -N).
for i in {1..9}; do
  alias $i="cd -$i"
  alias cd$i="cd -$i"
done
# '1' or 'cd1' moves to the most recent directory.
# '2' or 'cd2' moves to the second most recent directory.
# etc.

alias -g 21="2>&1"                      # Redirect stderr to stdout.
alias -g N='> /dev/null'                # Redirect output to null (discard).
alias -g NN='> /dev/null 2>&1'          # Redirect both stdout and stderr to null.

alias -g A='| awk'                      # Pipe output to awk.
alias -g G='| grep --color=auto -E'     # Grep with color highlighting and extended regex.
alias -g J='| jq -C .'                  # Pretty-print JSON with jq, maintaining colors.
alias -g S='| sort'                     # Sort output.
alias -g U='| uniq'                     # Filter unique lines from output.
alias -g W='| wc -l'                    # Count lines in output.
alias -g T='| tail'                     # Pipe to tail.
alias -g H='| head'                     # Pipe to head.

# Count and sort unique items with frequencies.
alias -g CS='sort | uniq -c | sort -k1,1nr'

alias -g CA="| cat -A"                  # Display line endings and tab characters (cat -A).
alias -g F='| fmt -'                    # Format output to fit within a specific width.
alias -g L="| less"                     # Pipe to less for paginated viewing.

alias -g BG='& exit'                    # Send process to background and exit shell.

alias -g X='| xargs'                    # Pipe args to a target command.
alias -g X0='| tr "\n" "\0" | xargs -0' # Null-separated input (safe for spaces/newlines).
alias -g X1='| xargs -n 1'              # One arg per call.
alias -g XR='| xargs -r'                # Run only if input is non-empty.

alias -g Map="| tr '\n' '\0' | xargs -0 -n 1"

# Field extractors.
for i in {1..9}; do
    alias -g "A$i"="| awk '{print \$$i}'"
done

for i in {1..9}; do
    alias -g ",$i"="| awk -F, '{print \$$i}'"
done

for i in {1..9}; do
    alias -g "S$i"="| awk -F';' '{print \$$i}'"
done

for i in {1..9}; do
    alias -g ":$i"="| awk -F: '{print \$$i}'"
done

for i in {1..9}; do
    alias -g "T$i"="| awk -F \$'\\t' '{print \$$i}'"
done

# Bind common escape sequences for arrow keys with modifiers.
bindkey "\e[1;5D" backward-word         # Ctrl+Left.
bindkey "\e[1;5C" forward-word          # Ctrl+Right.
bindkey "\e[1;3D" backward-word         # Alt+Left.
bindkey "\e[1;3C" forward-word          # Alt+Right.

# M-S-l: Send the string 'ls' followed by a newline.
bindkey -s '\eL' 'ls\n'

# C-M-u: Move to parent directory.
up-directory() {
  local count=${1:-1}
  while (( count > 0 )); do
      cd ..
      ((count--))
  done
  zle reset-prompt
}
zle -N up-directory
bindkey '\e\C-u' up-directory

# M-s: Prepend sudo.
prepend-sudo() {
  # If the buffer is empty, recall the previous command from history.
  [[ -z $BUFFER ]] && zle up-history
  # Only prepend 'sudo' if it's not already at the start.
  if [[ $LBUFFER != sudo* ]]; then
    LBUFFER="sudo $LBUFFER"
  fi
  zle reset-prompt
}
zle -N prepend-sudo
bindkey "\es" prepend-sudo

bindkey '^x^d' copy-prev-word
# Instead of C-M-_.

# Load the edit-command-line function.
autoload -Uz edit-command-line
zle -N edit-command-line

# Bind C-x C-e to open the command line in an external editor.
bindkey '^x^e' edit-command-line

# -------------------------------------------------
# Zsh Powerline Prompt - Identical to Bash
# -------------------------------------------------
setopt PROMPT_SUBST
autoload -Uz add-zsh-hook

# === Git Status (replaces __git_ps1) ===
git_prompt_info() {
    git rev-parse --is-inside-work-tree &>/dev/null || return

    local branch git_status=''  # ← Renamed from 'status' to avoid conflict

    branch=$(git symbolic-ref --short HEAD 2> /dev/null || git rev-parse --short HEAD 2> /dev/null)

    # Unstaged changes
    [[ -n $(git diff --no-ext-diff --shortstat 2> /dev/null) ]] && git_status+='%F{red}●%f'
    # Staged changes
    [[ -n $(git diff --cached --shortstat 2> /dev/null) ]] && git_status+='%F{green}+%f'
    # Stashes
    git rev-parse --verify refs/stash &>/dev/null && git_status+='%F{cyan}$%f'
    # Untracked files
    [[ -n $(git ls-files --others --exclude-standard 2> /dev/null) ]] && git_status+='%F{yellow}?%f'

    # Ahead / Behind
    if upstream=$(git rev-parse --abbrev-ref @{u} 2> /dev/null); then
        local ahead behind
        ahead=$(git rev-list --count "$upstream"..HEAD 2> /dev/null)
        behind=$(git rev-list --count HEAD.."$upstream" 2> /dev/null)
        (( ahead )) && git_status+="%F{magenta}▲$ahead%f"
        (( behind )) && git_status+="%F{cyan}▼$behind%f"
    fi

    [[ -n $git_status ]] && git_status=" $git_status"
    print -n "%F{15}$branch$git_status%f"
}

# === Right Prompt: Exit Code ===
exit_code_rprompt() {
    local code=$?
    (( code == 0 )) && { RPROMPT=''; return; }

    local -A bsd_codes=(
        64 EX_USAGE 65 EX_DATAERR 66 EX_NOINPUT 67 EX_NOUSER 68 EX_NOHOST
        69 EX_UNAVAILABLE 70 EX_SOFTWARE 71 EX_OSERR 72 EX_OSFILE 73 EX_CANTCREAT
        74 EX_IOERR 75 EX_TEMPFAIL 76 EX_PROTOCOL 77 EX_NOPERM 78 EX_CONFIG
    )

    local sym=${bsd_codes[$code]}
    local msg=" Exit $code${sym:+ ($sym)}"

    local cols=${COLUMNS:-$(tput cols)}
    local len=$(( ${#msg} + 4 ))  #  + msg + ■ + space
    local pad=$(( cols - len ))

    RPROMPT="%F{red}%K{black}%f%k%K{red}%F{white}$msg%f%k%F{white}%K{red} ■ %f%k%${pad}G"
}

# === Build Main Prompt ===
build_prompt() {
    local userhost="%K{136}%F{234} %n@%m %f%k"
    local dir="%K{25}%F{15} %~ %f%k"
    local sep1="%F{136}%K{25}%f%k"
    local sep2="%F{25}%K{240}%f%k"
    local sep3="%F{240}%K{black}%f%k"
    local final_sep="%F{25}%K{black}%f%k"

    PS1=$'\n'"$userhost$sep1$dir"

    if git rev-parse --is-inside-work-tree &>/dev/null; then
        PS1+="$sep2%K{240}%F{15} $(git_prompt_info) %f%k$sep3"
    else
        PS1+="$final_sep"
    fi

    PS1+=$'\n%B%F{white}\$%f%b '
}

# === Update on every command ===
precmd() {
    exit_code_rprompt
    build_prompt
}

# Activate
add-zsh-hook precmd precmd

# Search command history based on what is typed.
autoload -Uz up-line-or-beginning-search
autoload -Uz down-line-or-beginning-search

# Create the widgets (they are built-in in recent Zsh).
zle -N up-line-or-beginning-search
zle -N down-line-or-beginning-search

# Bind the *real* escape sequences that your terminal sends
bindkey "${terminfo[kcuu1]:-^[[A}" up-line-or-beginning-search   # Up arrow.
bindkey "${terminfo[kcud1]:-^[[B}" down-line-or-beginning-search # Down arrow.

# Set a common history file.
HISTFILE=$HOME/.zsh_history

# Set the number of history entries to save to the (on-disk history) file.
SAVEHIST=20000

# Share history between all running sessions.
setopt SHARE_HISTORY

# Append commands to the history file incrementally, instead of overwriting the
# history file when the shell exits.
setopt INC_APPEND_HISTORY

# Append to the history file instead of overwriting it.
setopt APPEND_HISTORY

setopt HIST_IGNORE_SPACE
setopt HIST_SAVE_NO_DUPS
setopt HIST_EXPIRE_DUPS_FIRST

# Show full command history without line numbers.
alias history="history 0"

# Color stderr.
zmodload zsh/system
color_stderr_red() {
    # Sysread & syswrite are part of `zsh/system'.
    emulate -LR zsh
    local stderr_red_esc_code=$'\e[37;1;41m'
    while sysread; do
        syswrite -o 2 "${stderr_red_esc_code}${REPLY}$terminfo[sgr0]"
    done
}

# Redirect stderr to color_stderr_red function.
exec 2> >(color_stderr_red)
