#+TITLE: ShellBoost configuration files

#+PROPERTY:  header-args :tangle bin/rc-common-settings-shellboost

#+name: current-time
#+begin_src emacs-lisp :eval yes :results value :tangle no
(format-time-string "<%Y%m%d.%H%M>")
#+end_src

#+begin_src shell :noweb yes
# Hey Emacs, this is a -*- sh -*- file ...
# NOTE: This file is meant to be sourced (e.g. from .bashrc or .zshrc)

# Last modified: <<current-time()>>

# Customize shell environment with aliases, PATH tweaks, and tool enhancements.
#+end_src

Welcome to the *ShellBoost configuration files* project!  This repository is a
go-to solution for streamlining and enhancing your terminal experience. Whether
you're developer, sysadmin, or an enthusiast, this configuration provides
a well-organized, modular, and efficient way to customize your shell
environment.

#+begin_quote
[!TIP]

*** Master the command line in Paris on 26 November 2025!
Unlock the full power of your system with the exclusive "ShellBoost" course.

Visit https://shellboost.fr/ for details and registration,
and to /secure your place today/.
#+end_quote

* What's inside?

This project includes a comprehensive set of configuration files and scripts
designed to optimize your *Bash* or *Zsh* shell. Here's a quick overview of what
you'll find:

- *Environment variables:* Define global variables for seamless shell behavior.
- *Paths:* Configure system paths to access your tools effortlessly.
- *Aliases:* Simplify commands with powerful shortcuts.
- *Functions:* Extend shell functionality with custom functions.
- *Key bindings:* Speed up workflows with custom key mappings.
- *Prompt configuration:* Personalize your shell prompt with style and utility.
- *Autosuggestions:* Type fewer keystrokes with intelligent command predictions.
- *Completions:* Enjoy enhanced tab completions for efficiency.
- *Universal variables:* Set shared variables across sessions and systems.
- *Abbreviations:* Save time with shorthand command expansions.
- *Event handling:* Automate responses to shell events for smarter scripting.
- *Miscellaneous settings:* Additional tweaks and optimizations.

* Why use ShellBoost configurations?

- *Highly modular:* Each feature is encapsulated, making it easy to modify or
  extend.
- *Cross-compatible:* Works seamlessly with both *Bash* and *Zsh*.
- *Optimized for productivity:* Every setting is curated to save time and reduce
  friction.
- *Customizable:* Add or tweak configurations to fit your unique needs.

* Getting started

** Try online

You can try ShellBoost without installing it by running the following commands
in your shell:

- *For Bash users*

  #+begin_src shell :tangle no
  # Load common settings.
  curl -sSL https://raw.githubusercontent.com/fniessen/shellboost/refs/heads/master/bin/rc-common-settings-shellboost | bash -

  # Load Bash-specific settings.
  curl -sSL https://raw.githubusercontent.com/fniessen/shellboost/refs/heads/master/bin/rc-bash-specific-settings-shellboost | bash -
  #+end_src

- *For Zsh users*

  #+begin_src shell :tangle no
  # Load common settings.
  curl -sSL https://raw.githubusercontent.com/fniessen/shellboost/refs/heads/master/bin/rc-common-settings-shellboost | zsh -

  # Load Zsh-specific settings.
  curl -sSL https://raw.githubusercontent.com/fniessen/shellboost/refs/heads/master/bin/rc-zsh-specific-settings-shellboost | zsh -
  #+end_src

These commands will download and execute the configuration files directly in
your current shell session, enabling you to explore ShellBoost's features
right away.

** Automating custom configuration

To load custom settings automatically when your shell starts, follow these
steps:

1. Clone the repository:

   #+begin_src shell :tangle no
   git clone git@github.com:fniessen/shellboost.git
   #+end_src

2. Integrate configurations with your shell:

   - *For Bash users*

     Add the following lines to your =.bashrc=:

     #+begin_src shell :tangle no
     source /PATH/TO/shellboost/bin/rc-common-settings-shellboost
     source /PATH/TO/shellboost/bin/rc-bash-specific-settings-shellboost  # For Bash.
     #+end_src

     or, more generally (and if the files are symlinked into =~/bin=)

     #+begin_src shell :tangle no
     # Source custom settings files (beginning with 'rc-bash' or 'rc-common') from
     # ~/bin.
     for file in ~/bin/rc-bash-specific-settings-* \
                 ~/bin/rc-common-settings-*; do
         if [ -f "$file" ]; then
             printf "Sourcing %s...\n" "$file"
             . "$file"
         fi
     done
     #+end_src

   - *For Zsh users*

     Add the following lines to your =.zshrc=:

     #+begin_src shell :tangle no
     source /PATH/TO/shellboost/bin/rc-common-settings-shellboost
     source /PATH/TO/shellboost/bin/rc-zsh-specific-settings-shellboost   # For Zsh.
     #+end_src

     or, more generally (and if the files are symlinked into =~/bin=)

     #+begin_src shell :tangle no
     # Source custom settings files (beginning with 'rc-zsh' or 'rc-common') from
     # ~/bin.
     for file in ~/bin/rc-zsh-specific-settings-* \
                 ~/bin/rc-common-settings-*; do
         if [ -f "$file" ]; then
             printf "Sourcing %s...\n" "$file"
             . "$file"
         fi
     done
     #+end_src

3. Reload your shell:

   #+begin_src shell :tangle no
   source ~/.bashrc  # For Bash.
   # OR
   source ~/.zshrc  # For Zsh.
   #+end_src

* 1. Environment variables

These are variables that are accessible to all parts of the shell
environment.

#+begin_src shell :noweb yes :tangle bin/rc-bash-specific-settings-shellboost
# Hey Emacs, this is a -*- sh -*- file ...
# NOTE: This file is meant to be sourced (e.g. from .bashrc or .zshrc)

# Last modified: <<current-time()>>
#+end_src

#+begin_src shell :noweb yes :tangle bin/rc-zsh-specific-settings-shellboost
# Hey Emacs, this is a -*- sh -*- file ...
# NOTE: This file is meant to be sourced (e.g. from .bashrc or .zshrc)

# Last modified: <<current-time()>>
#+end_src

** Editor configuration

This configuration sets the default text editor used by your shell. The editor
specified here will be used by commands like ~git~, ~crontab~, and
~EDITOR~ / ~VISUAL~-based commands for editing files.

#+begin_src shell :tangle bin/rc-common-settings-shellboost
# Set the default editor (change 'emacs' to your preferred editor).
export VISUAL=emacs
export EDITOR="$VISUAL"
#+end_src

- ~VISUAL~: Defines the preferred editor for applications that require
  a full-screen editor (like ~emacs~, etc.).

- ~EDITOR~: Specifies the default editor for command-line tools that invoke an
  editor without needing full-screen interaction.

** Localization and character encoding settings

The code snippet sets environment variables related to localization and
character encoding:

#+begin_src shell :tangle bin/rc-common-settings-shellboost
# Check and configure locale settings.
locale="en_US.utf8"

if locale -a | grep -q "$locale"; then
    export LANG="$locale"
    export LC_ALL="$LANG"               # Consistent character encoding.
    printf >&2 "Locale '%s' is set.\n" "$locale"
else
    printf >&2 "Warning: '%s' locale unavailable.\n" "$locale"
    printf >&2 "Hint: You may need to manually install it with 'sudo locale-gen %s'.\n" "$locale"
fi
#+end_src

- ~LC_ALL=en_US.utf8~: Forces all locale settings (including ~LANG~) to use
  U.S. English with UTF-8 encoding.
- ~LANG=en_US.utf8~: Sets the default locale for the system, influencing language
  and encoding preferences for programs.

This ensures consistent text encoding across applications, preventing issues
with character display and input.

** Configuring colors for 'ls'

The following example sets up ~LS_COLORS~ to define color schemes for ~ls~ based
on file types.

#+begin_src shell
if [ -r ~/.dircolors ]; then
    eval "$(dircolors ~/.dircolors)" || eval "$(dircolors)"  # Fallback to default.
fi
#+end_src

The ~dircolors~ command reads a configuration file (e.g., =~/.dircolors=) to define
color mappings and assigns the output to the ~LS_COLORS~ variable.

** Customizing time format for 'ls'

The ~TIME_STYLE~ environment variable customizes the display of dates and times in
the output of the ~ls~ command. For instance:

#+begin_src shell
# Configure the time format for `ls` to display dates as "YYYY-MM-DD Day HH:MM".
export TIME_STYLE=+"%Y-%m-%d %a %H:%M"
#+end_src

This setting formats timestamps in a human-readable ISO-like format with the day
of the week included.

* 2. Paths

This section covers essential paths for files and directories, including how to
configure the ~PATH~ environment variable. The ~PATH~ variable tells the shell where
to look for executable files, ensuring that commands and scripts can be run from
any location without specifying their full path.

** Modifying PATH

To dynamically add directories to ~PATH~, we define a helper function that checks
if a directory is already present before appending it. This prevents duplicate
entries and maintains an organized environment.

#+begin_src shell
# Function to add a directory to PATH if it's not already included.
lvn_add_to_path() {
    local dir="$1"
    if [ -d "$dir" ] && [[ ":$PATH:" != *":$dir:"* ]]; then
        export PATH="$dir:$PATH"
    fi
}

# Add user-specific binary directories.
lvn_add_to_path "$HOME/bin"
lvn_add_to_path "$HOME/winbin"
#+end_src

This setup ensures that executables stored in =~/bin= and =~/winbin= are accessible
from the command line.

** TeX Live configuration

: update-dotfiles
: tlmgr install gillius
: tlmgr update --self
: sudo apt remove texlive*
: sudo apt install texlive
: sudo apt remove texlive*
: wget https://mirror.ctan.org/systems/texlive/tlnet/install-tl-unx.tar.gz
: tar -xvzf install-tl-unx.tar.gz
: cd install-tl-*
: sudo ./install-tl
: cd install-tl-20250130/
: sudo ./install-tl
: sudo tlmgr update --self
: sudo /usr/local/texlive/2024/bin/x86_64-linux/tlmgr update --self
: sudo /usr/local/texlive/2024/bin/x86_64-linux/tlmgr  install gillius
: export PATH=$PATH:/usr/local/texlive/2024/bin/x86_64-linux

# export PATH=/usr/local/texlive/2024/bin/x86_64-linux:$PATH
# export MANPATH=/usr/local/texlive/2024/texmf-dist/doc/man:$MANPATH
# export INFOPATH=/usr/local/texlive/2024/texmf-dist/doc/info:$INFOPATH

The following script configures TeX Live by updating ~PATH~, ~MANPATH~, and ~INFOPATH~
to include the relevant directories if TeX Live is installed.

#+begin_src shell
TEXLIVE_BASE="/usr/local/texlive"
TL_PLATFORM="$(uname -m)-linux"

# Pick newest installed /usr/local/texlive/YYYY.
TEXLIVE_DIR="$(
  find "$TEXLIVE_BASE" -mindepth 1 -maxdepth 1 -type d -name '20[0-9][0-9]' 2> /dev/null \
      | sort -r \
      | head -n 1
)"

if [ -n "$TEXLIVE_DIR" ] && [ -d "$TEXLIVE_DIR" ]; then
    # Compute bin path.
    TEXLIVE_BIN="${TEXLIVE_DIR}/bin/${TL_PLATFORM}"

    # Add TeX Live binaries to PATH.
    lvn_add_to_path "$TEXLIVE_BIN"

    # Ensure MANPATH and INFOPATH exist.
    MANPATH="${MANPATH:-}"
    INFOPATH="${INFOPATH:-}"

    # Add TeX Live documentation paths (append with ':' only if non-empty).
    export MANPATH="${MANPATH:+${MANPATH}:}${TEXLIVE_DIR}/texmf-dist/doc/man"
    export INFOPATH="${INFOPATH:+${INFOPATH}:}${TEXLIVE_DIR}/texmf-dist/doc/info"

    printf >&2 'TeX Live found: %s (%s)\n' "$TEXLIVE_DIR" "$TL_PLATFORM"
else
    printf >&2 'No TeX Live installation detected.\n'
fi
#+end_src

This ensures that TeX Live executables, such as ~pdflatex~ and ~lualatex~, are
available in the shell, and that manual and info pages for TeX Live can be
accessed using ~man~ and ~info~ commands.

* 3. Aliases

These are abbreviated commands designed for quicker execution.

This setup aims to enhance efficiency by offering intuitive shortcuts for
frequently used shell operations.

** Listing directories and files

The following aliases enhance the functionality of the ~ls~ command, making it
easier to navigate and view directory contents:

#+begin_src shell
# Columnar format with type indicators.
alias l='ls -CF'

# List directories only.
alias lsd='ls -d */'

# List files only.
alias lsf='ls -p | grep -v /'

# Detailed directory listing.
alias ll='ls -l'
#+end_src

** Changing working directory

*** Navigating up levels

#+begin_src shell
# Define aliases for changing directory up levels.
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
#+end_src

#+begin_src shell
# Switch to previous directory.
alias -- -='cd -'
#+end_src

*** Directory stack (for easy navigation)

**** Viewing the directory stack

#+begin_src shell
# Show the directory stack (entries 1-9), excluding the current directory.
alias d='dirs -v | tail -n +2 | head -n 9'
#+end_src

**** Auto-adding directories to stack on 'cd'

***** Configuration for Bash

Automatically track directories when using ~cd~:

#+begin_src shell :tangle bin/rc-bash-specific-settings-shellboost
# Set the maximum directory stack size to 10.
DIRSTACKSIZE=10
export DIRSTACKSIZE

# Check if realpath is available; if not, warn about potential issues.
if ! command -v realpath > /dev/null 2>&1; then
    printf >&2 "Warning: 'realpath' not found. Directory stack normalization may not work correctly.\n"
fi

# Custom cd function that maintains a directory stack with unique entries.
cd() {
    # Attempt to change directory using built-in cd.
    if builtin cd "$@" 2> /dev/null; then
        # Normalize the current directory path for comparison.
        local current_dir
        current_dir=$(realpath "$PWD" 2> /dev/null || printf "%s\n" "$PWD")

        # Get the current directory stack without the top entry (current dir).
        local stack
        stack=$(dirs -p -l | tail -n +2)

        # Clear the existing stack to rebuild it without duplicates.
        while popd -n > /dev/null 2>&1; do :; done

        # Rebuild the stack, excluding the current directory.
        local temp_stack=()
        while IFS= read -r dir; do
            # Normalize directory path for comparison.
            local normalized_dir
            normalized_dir=$(realpath "$dir" 2> /dev/null || printf "%s\n" "$dir")
            if [[ "$normalized_dir" != "$current_dir" ]]; then
                temp_stack+=("$dir")
            fi
        done <<< "$stack"

        # Push unique directories back to the stack, respecting DIRSTACKSIZE.
        local stack_size=${#temp_stack[@]}
        for ((i=$stack_size-1; i>=0 && stack_size<${DIRSTACKSIZE:-10}-1; i--)); do
            pushd -n "${temp_stack[$i]}" > /dev/null 2>&1
            ((stack_size++))
        done

        # Add the current directory to the stack.
        pushd -n "$PWD" > /dev/null 2>&1

        # # Provide feedback (show stack excluding the current directory at index 0).
        # dirs -v | tail -n +2 | head -n 9 | sed 's/^ //'
    else
        printf >&2 "cd: Failed to change directory to: %s\n" "$*"
        return 2
    fi
}
#+end_src

This ensures every ~cd~ command saves the directory in the stack.

***** Configuration for Zsh

#+begin_src shell :tangle bin/rc-zsh-specific-settings-shellboost
# Exit if not running in Zsh.
if [ -z "$ZSH_VERSION" ]; then
    printf >&2 "ERROR: This script requires Zsh. Aborting.\n"
    return 1
fi

# Set the maximum directory stack size to 10.
DIRSTACKSIZE=10
export DIRSTACKSIZE

setopt AUTO_PUSHD
setopt PUSHD_IGNORE_DUPS
#+end_src

**** Quick access to recently used directories

You can use the directory stack to quickly navigate to previously visited
directories.

Example of use:

#+begin_src shell :tangle no
pushd /etc
pushd /usr
pushd /var

dirs
# 0  /var
# 1  /usr
# 2  /etc
# 3  ~

cd1  # Equivalent to cd -1 -> /usr.
cd2  # Equivalent to cd -2 -> /etc.
#+end_src

***** Configuration for Bash

#+begin_src shell :tangle bin/rc-bash-specific-settings-shellboost
# Jump to a directory by visible stack index (as shown in 'dirs -v').
jumpd() {
    local index="$1"

    if ! [[ "$index" =~ ^[0-9]+$ ]]; then
        printf >&2 "jumpd: Index must be a non-negative number\n"
        return 64                       # EX_USAGE: Command-line usage error.
    fi

    local line
    line=$(dirs -v | awk -v idx="$index" '$1 == idx { $1=""; sub(/^ +/, ""); print }')

    if [ -z "$line" ]; then
        printf >&2 "jumpd: Invalid index: %s\n" "$index"
        return 65                       # EX_DATAERR: Data format error.
    fi

    # Expand ~ using eval.
    local target_dir
    target_dir=$(eval printf "%s\\\n" "$line") # With newline.

    if builtin cd "$target_dir" 2> /dev/null; then
        # Successfully changed directory, do nothing.
        :
    else
        printf >&2 "jumpd: Failed to cd to: %s\n" "$target_dir"
        return 71                       # EX_OSERR: System error.
    fi
}

# Define cdN() functions for switching to specific stack entries using jumpd.
for i in {1..9}; do
  eval "cd$i() { jumpd $i; }"
done
# 'cd1' moves to the most recent directory.
# 'cd2' moves to the second most recent directory.
# etc.
#+end_src

***** Configuration for Zsh

Normally, ~cd -1~ moves to the *previous directory* in the stack, ~cd -2~ to the one
before that, and so on. However, with the following aliases, you can simply type
the number of the stack entry you want to visit, like ~1~.

#+begin_src shell :tangle bin/rc-zsh-specific-settings-shellboost
# Define aliases for switching to specific stack entries (cd -N).
for i in {1..9}; do
  alias $i="cd -$i"
  alias cd$i="cd -$i"
done
# '1' or 'cd1' moves to the most recent directory.
# '2' or 'cd2' moves to the second most recent directory.
# etc.
#+end_src

*** Windows Subsystem For Linux (WSL) specific aliases

See also [[https://github.com/fniessen/wsl][wsl Git repository]].

** Command history search

Search the command history for a specified term, ignoring case sensitivity.

#+begin_src shell
# Search shell history for a term (case-insensitive, with color highlights).
hgrep() {
    history | grep -i --color=auto "$@"
}
#+end_src

#+begin_tip
We can't call this alias ~hg~ as that conflicts with the Mercurial prompt of the
Agnoster theme (checking for the presence of the ~hg~ command).
#+end_tip

#+begin_src shell
# Re-run previous commands using 'fc' (without conflicts with the R language).
rr='fc -s'
#+end_src

Examples:
- ~rr cc~ repeats the last command starting with ~cc~.
- ~rr~ repeats the previous command.

Alternatively, you can navigate history directly:
- Up arrow (~history-search-backward~): searches backward through commands
- Down arrow (~history-search-forward~): searches forward through commands

** Ripgrep enhancements

If the ~rg~ (Ripgrep) command is available, several customizations and aliases are
provided to enhance its functionality:

#+begin_src shell
# Check if 'rg' command is available.
if command -v rg > /dev/null 2>&1; then
    # Note: Install ripgrep with 'sudo apt install ripgrep' if missing.
#+end_src

*************** TODO Exclude any file inside a .git/ directory, while still allowing results from Git repositories themselves

#+begin_src shell
    # Ripgrep with context, colorized output, and case-insensitive search.
    rgci() {
        if [[ $# -eq 0 ]]; then
            printf >&2 '\033[1;37;41mUsage: rgci PATTERN\033[0m\n'
            return 64                   # EX_USAGE: Command-line usage error.
        fi
        local pattern="$*"
        rg -i -C 1 --hidden --no-ignore --glob '!.git' "$@" \
            | sed -E "/$pattern/! s/^.*$/\x1b[90m&\x1b[0m/; s/($pattern)/\x1b[1;31m\1\x1b[0m/gI"
    }
#+end_src

#+begin_src shell
    # Include hidden and ignored files by default.
    alias rg='rg --hidden --no-ignore'
#+end_src

#+begin_src shell
    # List matching filenames (like `rg -l`) while:
    # - Including hidden and ignored files
    # - Excluding any files under `.git/` directories
    rgno() {
        rg --hidden --no-ignore -l "$@" | grep -v '\.git/'
    }
#+end_src

#+begin_src shell
    # Search by file extension (case-insensitive).
    rgext() {
        if [[ $# -ne 2 ]]; then
            printf >&2 '\033[1;37;41mUsage: rgext EXTENSION PATTERN\033[0m\n'
            printf >&2 "Example: rgext txt 'hello world'\n"
            return 64                   # EX_USAGE: Command-line usage error.
        fi
        rg --hidden --no-ignore -i -C 1 --iglob "*.$1" "$2"
    }
#+end_src

#+begin_src shell
fi
#+end_src

** Global aliases for Zsh

This collection of global aliases is designed to streamline command-line
workflows in Zsh. These aliases expand automatically, regardless of their
position in a command, making frequently-used operations faster and more
intuitive.

*** Basic redirections

These aliases are used to handle output redirections, making common redirections
more concise and easy to use:

#+begin_src shell :tangle bin/rc-zsh-specific-settings-shellboost
alias -g 21="2>&1"                      # Redirect stderr to stdout.
alias -g N='> /dev/null'                # Redirect output to null (discard).
alias -g NN='> /dev/null 2>&1'          # Redirect both stdout and stderr to null.
#+end_src

*** Data processing

These aliases simplify common data processing tasks by chaining tools like ~awk~,
~grep~, ~jq~, and others for quick filtering and transformation:

#+begin_src shell :tangle bin/rc-zsh-specific-settings-shellboost
alias -g A='| awk'                      # Pipe output to awk.
alias -g G='| grep --color=auto -E'     # Grep with color highlighting and extended regex.
alias -g J='| jq -C .'                  # Pretty-print JSON with jq, maintaining colors.
alias -g S='| sort'                     # Sort output.
alias -g U='| uniq'                     # Filter unique lines from output.
alias -g W='| wc -l'                    # Count lines in output.
alias -g T='| tail'                     # Pipe to tail.
alias -g H='| head'                     # Pipe to head.
#+end_src

*** Counting and sorting unique items

For counting and sorting unique items along with their frequencies, use the
following alias:

#+begin_src shell :tangle bin/rc-zsh-specific-settings-shellboost
# Count and sort unique items with frequencies.
alias -g CS='sort | uniq -c | sort -k1,1nr'
#+end_src

*** Viewing and formatting output

These aliases are designed for better presentation of output, enabling paginated
views and formatting:

#+begin_src shell :tangle bin/rc-zsh-specific-settings-shellboost
alias -g CA="| cat -A"                  # Display line endings and tab characters (cat -A).
alias -g F='| fmt -'                    # Format output to fit within a specific width.
alias -g L="| less"                     # Pipe to less for paginated viewing.
#+end_src

*** Utility commands

These aliases are for handling tasks that support efficient command execution or
preparation:

#+begin_src shell :tangle bin/rc-zsh-specific-settings-shellboost
alias -g BG='& exit'                    # Send process to background and exit shell.

alias -g X='| xargs'                    # Pipe args to a target command.
alias -g X0='| tr "\n" "\0" | xargs -0' # Null-separated input (safe for spaces/newlines).
alias -g X1='| xargs -n 1'              # One arg per call.
alias -g XR='| xargs -r'                # Run only if input is non-empty.
#+end_src

*** Intuitive map function for list processing

The ~Map~ alias allows processing a list of newline-separated items seamlessly.

#+begin_src shell :tangle bin/rc-zsh-specific-settings-shellboost
alias -g Map="| tr '\n' '\0' | xargs -0 -n 1"
#+end_src

#+begin_note
*Robustness:* The extra ~| tr '\n' '\0' | xargs -0~ construct ensures that the alias
can handle inputs with spaces or special characters effectively, preventing
unexpected behavior in such cases.
#+end_note

*Example use case:*

List all directories containing a specific file, such as .git:

: find . -name .git Map dirname

*** Delimiter-separated outputs

These aliases allow quick *extraction* of specific *fields* from various
delimiter-separated outputs.

**** Space-separated (A)

#+begin_src shell :tangle bin/rc-zsh-specific-settings-shellboost
# Field extractors.
for i in {1..9}; do
    alias -g "A$i"="| awk '{print \$$i}'"
done
#+end_src

**** Comma-separated (,)

#+begin_src shell :tangle bin/rc-zsh-specific-settings-shellboost
for i in {1..9}; do
    alias -g ",$i"="| awk -F, '{print \$$i}'"
done
#+end_src

**** Semicolon-separated (S)

#+begin_src shell :tangle bin/rc-zsh-specific-settings-shellboost
for i in {1..9}; do
    alias -g "S$i"="| awk -F';' '{print \$$i}'"
done
#+end_src

**** Colon-separated (:)

#+begin_src shell :tangle bin/rc-zsh-specific-settings-shellboost
for i in {1..9}; do
    alias -g ":$i"="| awk -F: '{print \$$i}'"
done
#+end_src

**** Tab-separated (T)

#+begin_src shell :tangle bin/rc-zsh-specific-settings-shellboost
for i in {1..9}; do
    alias -g "T$i"="| awk -F \$'\\t' '{print \$$i}'"
done
#+end_src

** Tool upgrades

*** Better alternative to cat

The ~cat~ command is commonly used to display file contents, but ~bat~ is a more
feature-rich alternative. It adds syntax highlighting, line numbers, and
a better user interface for viewing files.

#+begin_src shell
# Check if bat is installed before aliasing cat.
if command -v bat > /dev/null 2>&1; then
    # Better cat.
    alias cat='bat'
fi
#+end_src

*** Better alternative to less

The ~less~ command is widely used for paging through long outputs. However, ~most~
offers additional features such as the ability to scroll backward and improved
performance, making it a better alternative.

~moar~ is a pager tool designed to be "nice to use for humans".

#+begin_src shell
# Check if moar is installed before aliasing less.
if command -v moar > /dev/null 2>&1; then
    # Better less.
    alias less='moar'
fi
#+end_src

*** Better alternative to top

The ~top~ command is commonly used to monitor system processes and resource
usage. However, ~htop~ is a more advanced and user-friendly alternative that
provides an interactive, colorized interface with better process management and
detailed metrics.

#+begin_src shell
# Check if htop is installed before aliasing top.
if command -v htop > /dev/null 2>&1; then
    # Better top.
    alias top='htop'
fi
#+end_src

*** Better alternative to df

The ~df~ command is used to display disk space usage, but ~duf~ (Disk Usage Free)
provides a more *user-friendly, colorful, and interactive* alternative. It offers
better readability, column sorting, and a clearer presentation of storage
information.

#+begin_src shell
# Check if duf is installed before aliasing df.
if command -v duf > /dev/null 2>&1; then
    # Better df.
    alias df='duf'
fi
#+end_src

*** Better alternative to traceroute

The ~traceroute~ command is used to trace the route packets take to
a destination. However, ~mtr~ (My Traceroute) is a more *powerful, real-time, and
interactive* alternative. It combines traceroute and ping, providing continuous
network diagnostics with a clearer and more dynamic interface.

#+begin_src shell
# Check if mtr is installed before aliasing traceroute.
if command -v mtr > /dev/null 2>&1; then
    # Better traceroute.
    alias traceroute='mtr -t'
    # Better tracepath.
    alias tracepath='mtr -t'
fi
#+end_src

* 4. Functions

These are blocks of code that can be executed by name.

#+begin_src shell :tangle no
confirm() {
    # Prompt the user for confirmation with a customizable message.
    read -p "$1 [y/N] " response
    case "$response" in
        [yY][eE][sS]|[yY])
            # Confirm with yes or y.
            return 0
            ;;
        ,*)
            # Default to no.
            return 1
            ;;
    esac
}

empty_trash() {
    # Confirm before proceeding.
    if confirm "Are you sure you want to empty the trash?"; then
        # Remove contents of the trash directory.
        if [[ "$OSTYPE" == "darwin"* ]]; then
            rm -rf ~/.Trash/*
        else
            rm -rf ~/.local/share/Trash/*
        fi
        printf "Trash emptied.\n"
    else
        printf "Operation cancelled.\n"
    fi
}
#+end_src

#+begin_src shell :tangle bin/rc-bash-specific-settings-shellboost
repeat() {
  local count=$1
  shift
  if [[ -z "$count" || "$count" -le 0 ]]; then
    printf "Usage: repeat N command [args...]\n"
    return 1
  fi
  for ((i=1; i<=count; i++)); do
    "$@"
  done
}
#+end_src

* 5. Key bindings

These are mappings of keys to commands.

- ~C-l~: clear the terminal screen.

** Finding and highlighting strings with C-S-f in WSL terminal

In the *Windows Subsystem for Linux (WSL)* terminal (or any Windows Terminal
session), you can quickly *search and highlight text* in the visible terminal
output using the shortcut ~C-S-f~.

When you press this key combination:

- A *search bar* appears at the top of the terminal window.

- As you type, all *matching strings* in the current scrollback buffer are
  *highlighted*.

- Press *Enter* to jump to the next match, or *S-Enter* to move to the previous one.

The search is *case-insensitive by default*, but you can toggle options (like case
sensitivity or regex search) using the icons in the search bar.

This search only operates within the *terminal display buffer* -- it does not
search through files or command history.

** Enable Emacs-style keybindings for command line editing

These commands enable Emacs-style keybindings, allowing you to use Emacs editing
commands (like ~C-a~ to move to the beginning of the line) for command line
editing.

They are the default.

*** Configuration for Bash

#+begin_src shell :tangle no
# Ensure Bash is in Emacs editing mode (required for key bindings).
set -o emacs
#+end_src

*** Configuration for Zsh

#+begin_src shell :tangle no
# Ensure Zsh is using Emacs-style bindings.
bindkey -e
#+end_src

** Cursor movement

- ~C-a~: Move cursor to the beginning of the line.
- ~C-e~: Move cursor to the end of the line.
- ~C-b~: Move cursor backward one character.
- ~C-f~: Move cursor forward one character.
- ~M-b~ or ~C-<left>~ or ~M-<left>~: Move cursor backward one word.
- ~M-f~ or ~C-<right>~ or ~M-<right>~: Move cursor forward one word.

~M-b~, ~M-f~, ~M-<left>~, ~M-<right>~ will move parameter by parameter, behaving like
Zsh (each argument separated by space, not by punctuation):

#+begin_src shell :tangle no
# Remove most punctuation from word delimiters.
bind 'set word-delimiters " \t\n"'
#+end_src

#+begin_src shell :tangle bin/rc-zsh-specific-settings-shellboost
# Bind common escape sequences for arrow keys with modifiers.
bindkey "\e[1;5D" backward-word         # Ctrl+Left.
bindkey "\e[1;5C" forward-word          # Ctrl+Right.
bindkey "\e[1;3D" backward-word         # Alt+Left.
bindkey "\e[1;3C" forward-word          # Alt+Right.
#+end_src

** Command History and Search

- ~<up>~: Navigate through command history.
- ~C-r~: Initiate a reverse search through command history.
- ~C-s~: Initiate a forward search through command history.
- ~M-<up>~ (with input): Search command history for commands starting with the current input.
- ~M-<down>~ (with input): Search command history for the next matching command.

** Command Editing

- ~C-d~: Delete the character under the cursor or exit the shell if the line is empty.
- ~C-k~: Kill (cut) text from the cursor to the end of the line.
- ~C-y~: Yank (paste) the previously killed text.
- ~C-c~: Cancel the current command (and clear the command line).
- ~M-e~: Open the current command line in your preferred text editor.
- ~C-u~: Clear the line from the cursor to the beginning.

** Case and Word Manipulation

- ~M-c~: Capitalize the current word.
- ~M-u~: Uppercase the current word.
- ~M-l~: Lowercase the current word.
- ~M-t~: Transpose (swap) the last two words.

** Shell Utilities

- ~M-w~: Show short description of a command.
- ~M-d~: Show documentation for current command.
- ~M-p~: Prepend 'sudo' to the current command.
- ~M-.~: Insert (yank) the *last argument* of the *previous command*. \\
  Pressing it *again repeatedly* cycles backward through earlier commands' last
  arguments.
- ~C-z~: Activate complete-and-search functionality.

** Custom key bindings

You can create custom key bindings.

For example:

Refresh command line

| Key binding | Meaning                                                                                                 |
|-------------+---------------------------------------------------------------------------------------------------------|
| C-M-u       | Move to parent directory                                                                                |
| M-s         | Prepend 'sudo ' to the current command                                                                  |
| M-S-l       | List directory contents                                                                                 |
| C-x C-e     | Edit the current command line in an external editor; similar to the ~fc~ ("fix command") shell built-in |

*** ls

**** Configuration for Bash

#+begin_src shell :tangle bin/rc-bash-specific-settings-shellboost
# M-S-l: Send the string 'ls' followed by a newline.
bind '"\eL": "ls\n"'
#+end_src

**** Configuration for Zsh

#+begin_src shell :tangle bin/rc-zsh-specific-settings-shellboost
# M-S-l: Send the string 'ls' followed by a newline.
bindkey -s '\eL' 'ls\n'
#+end_src

*** C-M-u: Move to parent directory

This configuration binds the ~C-M-u~ key combination to the ~up-directory~ function
in both Bash and Zsh shells. The function changes the current directory to its
parent (~cd ..~).

**** Configuration for Bash

#+begin_src shell :tangle bin/rc-bash-specific-settings-shellboost
# C-M-u: Move to parent directory.
bind '"\e\C-u": "cd ..\n"'
#+end_src

**** Configuration for Zsh

#+begin_src shell :tangle bin/rc-zsh-specific-settings-shellboost
# C-M-u: Move to parent directory.
up-directory() {
  local count=${1:-1}
  while (( count > 0 )); do
      cd ..
      ((count--))
  done
  zle reset-prompt
}
zle -N up-directory
bindkey '\e\C-u' up-directory
#+end_src

~up-directory~ moves up N directories from the current directory (default is 1 if
no argument is provided), then refreshes the zsh prompt.

*Key note:* In Zsh, the *prompt* is refreshed to *reflect the new directory* after the
change.

*** M-s: Prepend sudo

This configuration binds the ~M-s~ key combination to prepend ~sudo~ to the current
command in both Bash and Zsh shells.

**** Configuration for Bash

#+begin_src shell :tangle bin/rc-bash-specific-settings-shellboost
# M-s: Prepend sudo.
bind '"\es": "\C-asudo \C-e"'
#+end_src

**** Configuration for Zsh

#+begin_src shell :tangle bin/rc-zsh-specific-settings-shellboost
# M-s: Prepend sudo.
prepend-sudo() {
  # If the buffer is empty, recall the previous command from history.
  [[ -z $BUFFER ]] && zle up-history
  # Only prepend 'sudo' if it's not already at the start.
  if [[ $LBUFFER != sudo* ]]; then
    LBUFFER="sudo $LBUFFER"
  fi
  zle reset-prompt
}
zle -N prepend-sudo
bindkey "\es" prepend-sudo
#+end_src

*** Copy previous word from current line

**** Configuration for Bash

~copy-prev-word~ inserts the word immediately before the cursor (on the current
command line) at the cursor position. Bound to ~C-x C-d~.

#+begin_src shell :tangle bin/rc-bash-specific-settings-shellboost
# Function to copy the previous word before the cursor.
copy-prev-word() {
    local line="$READLINE_LINE"
    local point=$READLINE_POINT

    # Get the part of the line before the cursor.
    local left="${line:0:point}"

    # Use regex to match the last word before the cursor (including trailing
    # spaces).
    if [[ "$left" =~ ([^[:space:]]+)[[:space:]]*$ ]]; then
        local word="${BASH_REMATCH[1]}"

        # Insert the word at the cursor position.
        READLINE_LINE="${line:0:point}$word${line:point}"

        # Move the cursor forward past the inserted word.
        READLINE_POINT=$((point + ${#word}))
    fi
}

# Bind the function to C-x C-d.
bind -x '"\C-x\C-d":copy-prev-word'
#+end_src

**** Configuration for Zsh

#+begin_src shell :tangle bin/rc-zsh-specific-settings-shellboost
bindkey '^x^d' copy-prev-word
# Instead of C-M-_.
#+end_src

See also https://zsh.sourceforge.io/Guide/zshguide04.html.

*** Run help

**** Configuration for Bash

#+begin_src shell :tangle bin/rc-bash-specific-settings-shellboost
# Function to run help on the current command
run-help() {
    # Get the first word of the last command (i.e., the last command in the
    # pipeline or sequence).
    local cmd=$(printf "%s" "$READLINE_LINE" | awk -F'\\||;' '{print $NF}' | awk '{print $1}')

    # Check if there's a command to process.
    if [[ -n "$cmd" ]]; then
        # Show the man page for the command (if it exists).
        man "$cmd" 2> /dev/null || {
            # If no man page, use the `whatis` command for a brief description.
            whatis "$cmd" || printf "No help available for '%s'.\n" "$cmd"
        }
    else
        printf "No command to show help for.\n"
        return 1
    fi
}

# Bind the function run-help to M-h.
bind -x '"\eh": run-help'
#+end_src

**** Configuration for Zsh

For Zsh, use ~M-h~.

*** Editing the current command line in an external editor

These configurations allow you to use ~C-x C-e~ to open the current command line
in your preferred text editor. The editor used is determined by the ~$VISUAL~ or
~$EDITOR~ environment variable.

**** Configuration for Bash

In Bash, the ~edit-and-execute-command~ function allows you to open the current
command line in an external editor.

To use it, press ~C-x C-e~.

**** Configuration for Zsh

In Zsh, ~edit-command-line~ provides similar functionality. It must be *autoloaded*
and registered with ~zle~ before assigning a key binding.

#+begin_src shell :tangle bin/rc-zsh-specific-settings-shellboost
# Load the edit-command-line function.
autoload -Uz edit-command-line
zle -N edit-command-line

# Bind C-x C-e to open the command line in an external editor.
bindkey '^x^e' edit-command-line
#+end_src

** See all current key bindings

: bind -P

| Abort and Exit                      |
| Line and Word Movement              |
| History Navigation                  |
| Editing                             |
| Case and Word Manipulation          |
| Command Completion                  |
| Miscellaneous                       |
| Bracketed Paste                     |
| Character Deletion and Modification |
| Keyboard Macros                     |
| Character Search                    |
| Display and Redraw                  |
| Command and History Expansion       |
| Line and Word Editing               |
| Completion and Expansion            |
| Other Commands                      |


From Zsh, in table:
| C-x ? | _complete_debug                         |
| C-x a | _expand_alias                           |
| C-x c | _correct_word (or _correct_filename ??) |
| C-x d | _list_expansions                        |
| C-x e | _expand_word                            |
| C-x h | _complete_help                          |
| C-x m | _most_recent_file                       |
| M-a   | accept-and-hold                         |
| M-g   | get-line                                |


|                                       | Zsh function                        | Bash                                   |                                                                                                                                                  |
|---------------------------------------+-------------------------------------+----------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------|
| M-w                                   | copy-region-as-kill                 |                                        |                                                                                                                                                  |
| M-q                                   | push-line                           |                                        |                                                                                                                                                  |
| M-h                                   | run-help                            |                                        |                                                                                                                                                  |
| C-h, C-<backspace>                    | backward-delete-char                | backward-delete-char                   | Backward Delete Character                                                                                                                        |
| M-\                                   |                                     | delete-horizontal-space                | Delete Horizontal Space                                                                                                                          |
| C-x e                                 |                                     | call-last-kbd-macro                    | Call Last Keyboard Macro                                                                                                                         |
| C-x (                                 |                                     | start-kbd-macro                        | Start Keyboard Macro                                                                                                                             |
| C-x )                                 |                                     | end-kbd-macro                          | End Keyboard Macro                                                                                                                               |
| C-]                                   |                                     | character-search                       | Character Search                                                                                                                                 |
| C-M-]                                 |                                     | character-search-backward              | Character Search Backward                                                                                                                        |
| C-l                                   | clear-screen                        |                                        |                                                                                                                                                  |
| C-M-l                                 |                                     | clear-display                          | Clear Display                                                                                                                                    |
| C-M-i                                 |                                     | dynamic-complete-history               | Dynamic Complete History                                                                                                                         |
| M-^                                   |                                     | history-expand-line                    | History Expand Line                                                                                                                              |
| C-x C-x                               | exchange-point-and-mark             | exchange-point-and-mark                | Exchange Point and Mark                                                                                                                          |
| C-M-r, M-r                            |                                     | revert-line                            | Revert Line                                                                                                                                      |
| C-u                                   | kill-whole-line XXX                 | unix-line-discard                      | Unix Line Discard                                                                                                                                |
| M-g                                   |                                     | glob-complete-word                     | Glob Complete Word                                                                                                                               |
| C-x *                                 | expand-word                         | glob-expand-word                       | Glob Expand Word                                                                                                                                 |
| C-x g                                 | list-expand                         | glob-list-expansions                   | Glob List Expansions                                                                                                                             |
| M-*                                   |                                     | insert-completions                     | Insert Completions                                                                                                                               |
| C-x !                                 |                                     | possible-command-completions           | Possible Command Completions                                                                                                                     |
| C-o                                   |                                     | operate-and-get-next                   | Operate and Get Next                                                                                                                             |
| M-&                                   |                                     | tilde-expand                           | Tilde Expand                                                                                                                                     |
| C-M-y                                 |                                     | yank-nth-arg                           | Yank Nth Argument                                                                                                                                |
| C-g                                   | send-break                          | abort                                  | Abort                                                                                                                                            |
| C-a                                   | beginning-of-line                   | beginning-of-line                      | Move to Beginning of Line                                                                                                                        |
| C-e                                   | end-of-line                         | end-of-line                            | Move to End of Line                                                                                                                              |
| C-b                                   | backward-char                       | backward-char                          | Backward Character                                                                                                                               |
| C-f                                   | forward-char                        | forward-char                           | Forward Character                                                                                                                                |
| M-b                                   | backward-word                       | backward-word, shell-backward-word     | Backward Word                                                                                                                                    |
| M-f                                   | forward-word                        | forward-word, shell-forward-word       | Forward Word                                                                                                                                     |
| M-<                                   | beginning-of-buffer-or-history      | beginning-of-history                   | Beginning of History                                                                                                                             |
| M->                                   | end-of-buffer-or-history            | end-of-history                         | End of History                                                                                                                                   |
| C-p                                   | up-line-or-history                  | previous-history                       | Previous History                                                                                                                                 |
| <up>                                  | up-line-or-history                  |                                        | Previous History                                                                                                                                 |
| C-n                                   | down-line-or-history                | next-history                           | Next History                                                                                                                                     |
| <down>                                | down-line-or-history                |                                        | Next History                                                                                                                                     |
| C-r                                   | history-incremental-search-backward | reverse-search-history                 | Reverse Search History                                                                                                                           |
| C-s                                   | history-incremental-search-forward  | forward-search-history                 | Forward Search History                                                                                                                           |
| M-p                                   | history-search-backward             | non-incremental-reverse-search-history | Non-Incremental Reverse Search                                                                                                                   |
| M-n                                   | history-search-forward              | non-incremental-forward-search-history | Non-Incremental Forward Search                                                                                                                   |
| M-[A                                  |                                     | history-search-backward                | History Search Backward                                                                                                                          |
| M-[B                                  |                                     | history-search-forward                 | History Search Forward                                                                                                                           |
| C-d                                   | delete-char-or-list                 | delete-char                            | Delete Character Under Cursor                                                                                                                    |
| C-k                                   | kill-line                           | kill-line                              | Kill Line                                                                                                                                        |
| M-d                                   | kill-word                           | kill-word                              | Kill Word                                                                                                                                        |
| C-M-h, C-M-<backspace>, M-<backspace> | backward-kill-word                  | backward-kill-word                     | Backward Kill Word                                                                                                                               |
| C-w                                   | backward-kill-word                  | unix-word-rubout                       | Unix Word Rubout                                                                                                                                 |
| C-t                                   | transpose-chars                     | transpose-chars                        | Transpose Characters                                                                                                                             |
| M-t                                   | transpose-words                     | transpose-words                        | Transpose Words                                                                                                                                  |
| C-_ (or C-x C-u)                      | undo                                | undo                                   | Undo                                                                                                                                             |
| C-y                                   | yank                                | yank                                   | Yank (Paste)                                                                                                                                     |
| M-., M-_                              | insert-last-word                    | yank-last-arg, insert-last-argument    | Yank (Insert) Last Argument                                                                                                                      |
| M-y                                   | yank-pop                            | yank-pop                               | Yank Pop                                                                                                                                         |
| M-c                                   | capitalize-word                     | capitalize-word                        | Capitalize Word                                                                                                                                  |
| M-u                                   | up-case-word                        | upcase-word                            | Uppercase Word                                                                                                                                   |
| M-l                                   | down-case-word                      | downcase-word                          | Lowercase Word                                                                                                                                   |
| C-i                                   | complete-word                       | complete                               | Complete `external command', `builtin command', `shell function', `alias', `suffix alias', `reserved word', `job', `parameter', or `corrections' |
| M-!                                   |                                     | complete-command                       | Complete Command                                                                                                                                 |
| M-! (after typing !!)                 | expand-history                      |                                        |                                                                                                                                                  |
| M-/                                   |                                     | complete-filename                      | Complete Filename                                                                                                                                |
| M-@                                   |                                     | complete-hostname                      | Complete Hostname                                                                                                                                |
| M-$                                   |                                     | complete-variable                      | Complete Variable                                                                                                                                |
| M-{                                   |                                     | complete-into-braces                   | Complete into Braces                                                                                                                             |
| M-?                                   | which-command XXX                   | possible-completions                   | Possible Completions                                                                                                                             |
| C-x /                                 |                                     | possible-filename-completions          | Possible Filename Completions                                                                                                                    |
| C-x @                                 |                                     | possible-hostname-completions          | Possible Hostname Completions                                                                                                                    |
| C-x ~                                 |                                     | possible-username-completions          | Possible Username Completions                                                                                                                    |
| C-x $                                 |                                     | possible-variable-completions          | Possible Variable Completions                                                                                                                    |
| M-#                                   |                                     | insert-comment                         | Insert Comment                                                                                                                                   |
| C-q                                   | quoted-insert                       | quoted-insert                          | Quoted Insert                                                                                                                                    |
| C-x C-v                               |                                     | display-shell-version                  | Display Shell Version                                                                                                                            |
| C-M-e                                 |                                     | shell-expand-line                      | Shell Expand Line                                                                                                                                |
| C-@                                   | set-mark-command                    | set-mark                               | Set Mark                                                                                                                                         |

: bindkey

* 6. Prompt configuration

This is the configuration of the terminal prompt. This includes things like the
colors, the text that is displayed, and the layout of the prompt.

#+begin_src shell :tangle bin/rc-bash-specific-settings-shellboost
# 
# Powerline-style Git-enhanced Bash prompt with simulated RPROMPT.
# 

# Check if 'git' command is available.
if ! command -v git > /dev/null 2>&1; then
    printf >&2 "\033[1;37;41mERROR: 'git' command not found.\033[0m\n"
fi

boost_git_ps1() {
    git rev-parse --is-inside-work-tree > /dev/null 2>&1 || return
    local branch status dirty staged stash untracked outgoing incoming

    branch="$(git symbolic-ref --short -q HEAD 2> /dev/null || git rev-parse --short HEAD 2> /dev/null)"

    # Custom colors.
    local GIT_DIRTY_COLOR="\033[31;1m"
    local GIT_STAGED_COLOR="\033[32;1m"     # Green (good to go / ready).
    local GIT_STASH_COLOR="\033[36m"        # Cyan (info).
    local GIT_UNTRACKED_COLOR="\033[33;1m"  # Yellow (warning light).
    local GIT_OUTGOING_COLOR="\033[35;1m"   # Purple for contrast.
    local GIT_INCOMING_COLOR="\033[36;1m"   # Cyan (info).

    # Color the markers, don't reset immediately.
    # Dirty (unstaged).
    if ! git diff --quiet --no-ext-diff; then
        dirty="${GIT_DIRTY_COLOR}"
    fi

    # Staged.
    if ! git diff --cached --quiet; then
        staged="${GIT_STAGED_COLOR}+"
    fi

    # Stash.
    if git rev-parse --verify --quiet refs/stash > /dev/null 2>&1; then
        stash="${GIT_STASH_COLOR}\$"
    fi

    # Untracked.
    if git ls-files --others --exclude-standard 2> /dev/null | grep -q .; then
        untracked="${GIT_UNTRACKED_COLOR}?"
    fi

    # Ahead / Behind.
    if git rev-parse --abbrev-ref @{u} &> /dev/null 2>&1; then
        local counts count_outgoing count_incoming
        counts="$(git rev-list --left-right --count HEAD...@{u} 2> /dev/null)"
        count_outgoing=$(printf "%s\n" "$counts" | awk '{print $1}')
        count_incoming=$(printf "%s\n" "$counts" | awk '{print $2}')
        (( count_outgoing > 0 )) && outgoing="${GIT_OUTGOING_COLOR}$count_outgoing"
        (( count_incoming > 0 )) && incoming="${GIT_INCOMING_COLOR}$count_incoming"
    fi

    status="$dirty$staged$stash$untracked$outgoing$incoming"
    [[ -n "$status" ]] && status=" $status"

    printf "%b\n" "$branch$status"
}

# Display exit code at right if non-zero.
show_exit_code_rprompt() {
    local exit_code=$1
    if [[ $exit_code -ne 0 ]]; then
        local separator_left=""
        local white_square=""

        # BSD-style symbolic names for exit codes 64-78.
        local -A bsd_exit_codes=(
            [64]="EX_USAGE"
            [65]="EX_DATAERR"
            [66]="EX_NOINPUT"
            [67]="EX_NOUSER"
            [68]="EX_NOHOST"
            [69]="EX_UNAVAILABLE"
            [70]="EX_SOFTWARE"
            [71]="EX_OSERR"
            [72]="EX_OSFILE"
            [73]="EX_CANTCREAT"
            [74]="EX_IOERR"
            [75]="EX_TEMPFAIL"
            [76]="EX_PROTOCOL"
            [77]="EX_NOPERM"
            [78]="EX_CONFIG"
        )

        local symbolic_name=""
        if [[ ${bsd_exit_codes[$exit_code]+_} ]]; then
            symbolic_name=" (${bsd_exit_codes[$exit_code]})"
        fi

        local msg=" Exit $exit_code$symbolic_name"

        # Colors.
        local sep_color="\033[31;40m"       # Red fg on black bg.
        local msg_color="\033[1;37;41m"     # White fg on red bg.
        local square_color="\033[1;37;41m"  # White on red.
        local reset_color="\033[0m"

        # Format parts (do NOT include trailing space inside color!).
        local formatted_sep="${sep_color}${separator_left}${reset_color}"
        local formatted_msg="${msg_color}${msg}"
        local formatted_square="${square_color}${white_square} ${reset_color}"

        # Calculate visible length.
        local visible_len=$((${#msg} + 4))  #  + msg +  + 1 space.

        local term_cols=$(tput cols)
        local padding=$(( term_cols - visible_len ))

        printf "\033[s"                             # Save cursor.
        printf "\033[1G\033[%dC" "$padding"         # Move to column.
        printf "%b%b %b" "$formatted_sep" "$formatted_msg" "$formatted_square"
        printf "\033[u"                             # Restore cursor.
    fi
}

set_prompt() {
    # Powerline separators.
    local SEPARATOR_RIGHT=""
    local SEPARATOR_LEFT=""

    # Colors (with proper Bash escapes).
    local RESET="\[\033[0m\]"

    local USER_BG="\[\033[48;5;136m\]"
    local USER_FG="\[\033[38;5;234m\]"

    local DIR_BG="\[\033[48;5;25m\]"
    local DIR_FG="\[\033[38;5;15m\]"

    local GIT_BG="\[\033[48;5;240m\]"
    local GIT_FG="\[\033[38;5;15m\]"

    local FINAL_BG="\[\033[48;5;0m\]"         # Final background (e.g. black).
    local GIT_SEP_FG="\[\033[38;5;240m\]"     # Foreground same as GIT_BG for seamless look.
    local FINAL_SEP_FG="\[\033[38;5;25m\]"    # Match DIR_BG for clean blue separator.
    # Prompt assembly.
    PS1=""

    # First line: user@host and working directory.
    PS1+="\n"
    PS1+="${USER_BG}${USER_FG}\u@\h ${RESET}${DIR_BG}\[\033[38;5;136m\]${SEPARATOR_RIGHT}${RESET}"
    PS1+="${DIR_BG}${DIR_FG} \w ${RESET}"

    # Git status, only if inside repo.
    if git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
        PS1+="${GIT_BG}\[\033[38;5;25m\]${SEPARATOR_RIGHT}${RESET}"
        PS1+="${GIT_BG}${GIT_FG} $(boost_git_ps1) ${RESET}"
        PS1+="${GIT_SEP_FG}${FINAL_BG}${SEPARATOR_RIGHT}${RESET}"
    else
        # Always add a final left separator in blue if not inside Git.
        PS1+="${FINAL_SEP_FG}${FINAL_BG}${SEPARATOR_RIGHT}${RESET}"
    fi

    # Second line: prompt symbol.
    PS1+="\n\[\033[1m\]\$ \[\033[0m\]"
}

# Preserve last exit code, show right prompt, then set PS1.
PROMPT_COMMAND='last=$?; show_exit_code_rprompt $last; set_prompt'
#+end_src

#+begin_src shell :tangle bin/rc-zsh-specific-settings-shellboost
# -------------------------------------------------
# Zsh Powerline Prompt - Identical to Bash
# -------------------------------------------------
setopt PROMPT_SUBST
autoload -Uz add-zsh-hook

# === Git Status (replaces __git_ps1) ===
git_prompt_info() {
    git rev-parse --is-inside-work-tree &>/dev/null || return

    local branch git_status=''  #  Renamed from 'status' to avoid conflict

    branch=$(git symbolic-ref --short HEAD 2> /dev/null || git rev-parse --short HEAD 2> /dev/null)

    # Unstaged changes
    [[ -n $(git diff --no-ext-diff --shortstat 2> /dev/null) ]] && git_status+='%F{red}%f'
    # Staged changes
    [[ -n $(git diff --cached --shortstat 2> /dev/null) ]] && git_status+='%F{green}+%f'
    # Stashes
    git rev-parse --verify refs/stash &>/dev/null && git_status+='%F{cyan}$%f'
    # Untracked files
    [[ -n $(git ls-files --others --exclude-standard 2> /dev/null) ]] && git_status+='%F{yellow}?%f'

    # Ahead / Behind
    if upstream=$(git rev-parse --abbrev-ref @{u} 2> /dev/null); then
        local ahead behind
        ahead=$(git rev-list --count "$upstream"..HEAD 2> /dev/null)
        behind=$(git rev-list --count HEAD.."$upstream" 2> /dev/null)
        (( ahead )) && git_status+="%F{magenta}$ahead%f"
        (( behind )) && git_status+="%F{cyan}$behind%f"
    fi

    [[ -n $git_status ]] && git_status=" $git_status"
    print -n "%F{15}$branch$git_status%f"
}

# === Right Prompt: Exit Code ===
exit_code_rprompt() {
    local code=$?
    (( code == 0 )) && { RPROMPT=''; return; }

    local -A bsd_codes=(
        64 EX_USAGE 65 EX_DATAERR 66 EX_NOINPUT 67 EX_NOUSER 68 EX_NOHOST
        69 EX_UNAVAILABLE 70 EX_SOFTWARE 71 EX_OSERR 72 EX_OSFILE 73 EX_CANTCREAT
        74 EX_IOERR 75 EX_TEMPFAIL 76 EX_PROTOCOL 77 EX_NOPERM 78 EX_CONFIG
    )

    local sym=${bsd_codes[$code]}
    local msg=" Exit $code${sym:+ ($sym)}"

    local cols=${COLUMNS:-$(tput cols)}
    local len=$(( ${#msg} + 4 ))  #  + msg +  + space
    local pad=$(( cols - len ))

    RPROMPT="%F{red}%K{black}%f%k%K{red}%F{white}$msg%f%k%F{white}%K{red}  %f%k%${pad}G"
}

# === Build Main Prompt ===
build_prompt() {
    local userhost="%K{136}%F{234} %n@%m %f%k"
    local dir="%K{25}%F{15} %~ %f%k"
    local sep1="%F{136}%K{25}%f%k"
    local sep2="%F{25}%K{240}%f%k"
    local sep3="%F{240}%K{black}%f%k"
    local final_sep="%F{25}%K{black}%f%k"

    PS1=$'\n'"$userhost$sep1$dir"

    if git rev-parse --is-inside-work-tree &>/dev/null; then
        PS1+="$sep2%K{240}%F{15} $(git_prompt_info) %f%k$sep3"
    else
        PS1+="$final_sep"
    fi

    PS1+=$'\n%B%F{white}\$%f%b '
}

# === Update on every command ===
precmd() {
    exit_code_rprompt
    build_prompt
}

# Activate
add-zsh-hook precmd precmd
#+end_src

* 7. Autosuggestions

These are suggestions for commands that are based on the current input. For
example, if you type ~ls~, the shell might show you suggestions for other commands
that start with ~ls~.

* 8. Completions

These are completions for commands and file paths. For example, if you type ~cd~,
the shell might show you a list of directories that you can change to.

* 9. Universal variables

These are variables that are shared by all shells. For example, the ~USER~
variable tells the shell your username.

* 10. Abbreviations

These are shortened names for words or phrases. For example, you might set an
abbreviation for the word ~git~ to ~g~.

* 11. Event handling

This is the configuration of how the shell responds to events, such as key
presses and file system changes.

"Terminal Title"

* 12. Miscellaneous settings

This is a catch-all category for settings that don't fit into any of the other
categories.

# set -g fish_color_autosuggestion brblack
# set -g fish_color_match yellow

** Searching command history by prefix

Up/Down arrow  history search (search-as-you-type)

#+begin_src shell :tangle bin/rc-bash-specific-settings-shellboost
# Check if history search bindings are already set.
if ! bind -q history-search-backward > /dev/null 2>&1; then
    # If not set, configure Up and Down arrow keys for history search.
    bind '"\e[A": history-search-backward'  # Up arrow: Search backward in command history.
    bind '"\e[B": history-search-forward'   # Down arrow: Search forward in command history.
fi
#+end_src

#+begin_src shell :tangle bin/rc-zsh-specific-settings-shellboost
# Search command history based on what is typed.
autoload -Uz up-line-or-beginning-search
autoload -Uz down-line-or-beginning-search

# Create the widgets (they are built-in in recent Zsh).
zle -N up-line-or-beginning-search
zle -N down-line-or-beginning-search

# Bind the *real* escape sequences that your terminal sends
bindkey "${terminfo[kcuu1]:-^[[A}" up-line-or-beginning-search   # Up arrow.
bindkey "${terminfo[kcud1]:-^[[B}" down-line-or-beginning-search # Down arrow.
#+end_src

** History management

#+begin_src shell
# Ignore spaces and duplicates.
export HISTCONTROL=ignoreboth
# === default in Ubuntu
#+end_src

#+begin_src shell
# Store 10,000 commands in memory.
export HISTSIZE=10000

# ISO8601 timestamp (yyyy-mm-dd hh:mm).
export HISTTIMEFORMAT="%Y-%m-%d %H:%M  "

# Exclude common commands.
export HISTIGNORE="ls:cd:pwd:clear:history:exit:top:df"
#+end_src

** Common settings

#+begin_src shell :tangle bin/rc-bash-specific-settings-shellboost
# Enable case-insensitive directory completion.
bind "set completion-ignore-case on"
bind "set show-all-if-ambiguous on"
#+end_src

** Grep colors

#+begin_src shell
# Highlight matches.
export GREP_COLORS='ms=01;31:mc=01;31:sl=:cx=:fn=35:ln=32'
#+end_src

** Bash-specific settings

#+begin_src shell :tangle bin/rc-bash-specific-settings-shellboost
# Set a common history file.
HISTFILE=$HOME/.bash_history

# Set the number of history entries to save to the (on-disk history) file.
export HISTFILESIZE=20000

# Append to the history file instead of overwriting it.
shopt -s histappend

# Add history management to the existing PROMPT_COMMAND: after each command,
# append to the history file and reload it.
if [ -n "$PROMPT_COMMAND" ]; then
    PROMPT_COMMAND="$PROMPT_COMMAND; history -a; history -n"
else
    PROMPT_COMMAND="history -a; history -n"
fi
#+end_src

** Zsh-specific settings

#+begin_src shell :tangle bin/rc-zsh-specific-settings-shellboost
# Set a common history file.
HISTFILE=$HOME/.zsh_history

# Set the number of history entries to save to the (on-disk history) file.
SAVEHIST=20000

# Share history between all running sessions.
setopt SHARE_HISTORY

# Append commands to the history file incrementally, instead of overwriting the
# history file when the shell exits.
setopt INC_APPEND_HISTORY

# Append to the history file instead of overwriting it.
setopt APPEND_HISTORY

setopt HIST_IGNORE_SPACE
setopt HIST_SAVE_NO_DUPS
setopt HIST_EXPIRE_DUPS_FIRST

# Show full command history without line numbers.
alias history="history 0"
#+end_src

*** Stderr in red

Wrap text that goes to file with descriptor ~2~ with proper ANSI escape codes,
making text red.

#+begin_src shell :tangle bin/rc-zsh-specific-settings-shellboost
# Color stderr.
zmodload zsh/system
color_stderr_red() {
    # Sysread & syswrite are part of `zsh/system'.
    emulate -LR zsh
    local stderr_red_esc_code=$'\e[37;1;41m'
    while sysread; do
        syswrite -o 2 "${stderr_red_esc_code}${REPLY}$terminfo[sgr0]"
    done
}

# Redirect stderr to color_stderr_red function.
exec 2> >(color_stderr_red)
#+end_src

* Contribute to ShellBoost

Your support and contributions help make *ShellBoost* even better!  Whether it's
reporting issues, submitting patches, or simply showing your appreciation, every
bit counts. Here's how you can get involved:

**  Report issues

Found a bug?  [[https://github.com/fniessen/shellboost/issues/new][Let us know!]]

**  Submit patches

Have ideas for improvement?  We'd love to see them!

Contributions are always welcome, and patches -- big or small -- are highly
appreciated.

- Fork the repository
- Make your changes
- Submit a pull request

We can't wait to see your contributions! 

**  Support with donations

If *ShellBoost* has made your life easier or more enjoyable, consider supporting
its development:

 [[https://www.paypal.com/cgi-bin/webscr?cmd=_donations&business=VCVAS6KPDQ4JC&lc=BE&item_number=shellboost&currency_code=EUR&bn=PP%2dDonationsBF%3abtn_donate_LG%2egif%3aNonHosted][Donate via PayPal]]

Your donation helps keep this project alive and growing!

Thank you for your support! 

* License

Copyright (C) 2013-2025 Fabrice Niessen. All rights reserved.

Author: Fabrice Niessen \\
Keywords: shell bash zsh

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program. If not, see http://www.gnu.org/licenses/.

#+html: <a href="http://opensource.org/licenses/GPL-3.0">
#+html:   <img src="http://img.shields.io/:license-gpl-blue.svg" alt=":license-gpl-blue.svg" />
#+html: </a>
#+html: <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_donations&business=VCVAS6KPDQ4JC&lc=BE&item_number=shellboost&currency_code=EUR&bn=PP%2dDonationsBF%3abtn_donate_LG%2egif%3aNonHosted">
#+html:   <img src="https://www.paypalobjects.com/en_US/i/btn/btn_donate_LG.gif" alt="btn_donate_LG.gif" />
#+html: </a>
